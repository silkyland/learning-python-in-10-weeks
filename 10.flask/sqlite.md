# SQLite3

### SQLite คืออะไร และทำไมถึงนิยมใช้กับ Python และ Flask

   SQLite เป็นระบบจัดการฐานข้อมูลเชิงสัมพันธ์ (Relational Database Management System หรือ RDBMS) แบบฝังตัว (embedded) และเบา (lightweight) ที่จัดเก็บข้อมูลในไฟล์เดียว ง่ายต่อการติดตั้งและใช้งาน SQLite ได้รับความนิยมอย่างสูงในการพัฒนาแอปพลิเคชันกับ Python และ Flask ด้วยเหตุผลดังต่อไปนี้

   - มาพร้อมกับ Python: SQLite3 มาเป็นส่วนหนึ่งของไลบรารีมาตรฐานของ Python ไม่จำเป็นต้องติดตั้งแยกต่างหาก
   - ไม่ต้องการเซิร์ฟเวอร์แยก: ฐานข้อมูล SQLite จะถูกจัดเก็บเป็นไฟล์เดียว ไม่ต้องติดตั้งและกำหนดค่าเซิร์ฟเวอร์ฐานข้อมูลแยกต่างหาก
   - เรียนรู้ง่าย: SQLite ใช้ภาษาเดียวกับ SQL มาตรฐาน เรียนรู้ง่าย ใช้งานได้ทันที
   - เร็วและเบา: SQLite มีประสิทธิภาพสูงสำหรับแอปขนาดเล็กถึงกลาง ใช้หน่วยความจำและทรัพยากรเครื่องน้อย เหมาะสำหรับการทดสอบและพัฒนาแอป

###  ข้อดีของ SQLite เมื่อเทียบกับระบบฐานข้อมูลอื่นๆ

   เมื่อเทียบกับระบบฐานข้อมูลขนาดใหญ่อื่น ๆ เช่น MySQL, PostgreSQL, หรือ Oracle นั้น SQLite มีข้อดีหลายประการ ได้แก่

   - ติดตั้งง่าย: SQLite ไม่จำเป็นต้องติดตั้งและกำหนดค่าแยกต่างหาก ไม่ต้องใช้งานผ่าน server process หรือ service 
   - ใช้งานง่าย: เชื่อมต่อกับฐานข้อมูล SQLite เพียงแค่อ้างอิงไปยังไฟล์ฐานข้อมูล ใช้งานได้ทันที
   - Zero Configuration: SQLite ไม่จำเป็นต้องมีการตั้งค่าใดๆ ก่อนใช้งาน 
   - เบา: SQLite เหมาะสำหรับอุปกรณ์สเปคต่ำที่มีหน่วยความจำและพื้นที่จัดเก็บข้อมูลจำกัด
   - พกพาง่าย: ฐานข้อมูล SQLite ทั้งหมดจัดเก็บอยู่ในไฟล์เดียว ย้ายหรือคัดลอกไปยังเครื่องอื่นได้ง่าย
   - ใช้งานฟรี: SQLite เป็นโอเพนซอร์สและใช้งานได้ฟรี ไม่มีค่าใช้จ่ายสำหรับการใช้งานเชิงพาณิชย์

### เหมาะสำหรับแอปขนาดเล็กถึงกลาง หรือแอปที่ไม่ต้องการเซิร์ฟเวอร์ฐานข้อมูลแยก

   SQLite เหมาะอย่างยิ่งสำหรับแอปขนาดเล็กถึงกลางที่มีเนื้อหาหรือข้อมูลของผู้ใช้ไม่มาก หรือแอปที่ไม่จำเป็นต้องใช้เซิร์ฟเวอร์ฐานข้อมูลแยก ตัวอย่างเช่น

   - แอปที่ทำงานในเครื่อง (Desktop Apps)
   - แอปพลิเคชันเว็บขนาดเล็กถึงกลาง
   - เกมมือถือหรือเกมคอมพิวเตอร์
   - IoT และอุปกรณ์ฝังตัว (Embedded Devices)
   - แอปทดสอบและพัฒนา

   อย่างไรก็ตาม สำหรับแอปพลิเคชันที่ต้องการความสามารถในการเขียนข้อมูลแบบ Concurrent, High-Volume หรือมีโครงสร้างข้อมูลที่ซับซ้อน อาจต้องพิจารณาใช้ระบบฐานข้อมูลอื่นแทน เช่น MySQL หรือ PostgreSQL แต่สำหรับแอปขนาดเล็กถึงกลางที่ต้องการความง่ายและความคล่องตัว SQLite เป็นตัวเลือกที่ยอดเยี่ยม


## ติดตั้งและตั้งค่า SQLite

### SQLite มาพร้อมกับ Python ไม่จำเป็นต้องติดตั้งเพิ่ม

   SQLite เป็นส่วนหนึ่งของไลบรารีมาตรฐานของ Python ตั้งแต่ Python เวอร์ชัน 2.5 เป็นต้นมา ดังนั้น หากคุณมี Python ติดตั้งอยู่แล้ว คุณสามารถใช้ SQLite ได้ทันทีโดยไม่ต้องติดตั้งอะไรเพิ่มเติม เพียงแค่ import โมดูล `sqlite3` ใน Python script ของคุณ เช่น

   ```python
   import sqlite3
   ```

   คุณก็พร้อมที่จะเริ่มใช้งาน SQLite แล้ว

### วิธีสร้างไฟล์ฐานข้อมูลหรือเชื่อมต่อกับฐานข้อมูลที่มีอยู่

   เมื่อต้องการสร้างไฟล์ฐานข้อมูลใหม่หรือเชื่อมต่อกับไฟล์ฐานข้อมูลที่มีอยู่ คุณสามารถใช้ฟังก์ชัน `sqlite3.connect()` โดยส่งพาธ (path) ไปยังไฟล์ฐานข้อมูลเป็นอาร์กิวเมนต์ ตัวอย่างเช่น

   ```python
   # สร้างหรือเชื่อมต่อกับไฟล์ฐานข้อมูล 'mydatabase.db' ในไดเรกทอรีปัจจุบัน
   conn = sqlite3.connect('mydatabase.db')
   ```

   หากไฟล์ฐานข้อมูลที่ระบุไม่มีอยู่ SQLite จะสร้างไฟล์ใหม่โดยอัตโนมัติ หากมีอยู่แล้ว SQLite จะเปิดไฟล์นั้นและเชื่อมต่อเพื่อใช้งาน

### การใช้ SQLite ในโหมด in-memory สำหรับการทดสอบหรือข้อมูลชั่วคราว

   นอกจากการจัดเก็บข้อมูลในไฟล์ SQLite ยังรองรับการทำงานในโหมด "in-memory" ซึ่งจะเก็บข้อมูลทั้งหมดในหน่วยความจำแทนที่จะเขียนลงดิสก์ การทำงานในโหมดนี้เหมาะสำหรับการทดสอบหรือเมื่อต้องการจัดเก็บข้อมูลชั่วคราวที่ไม่จำเป็นต้องคงอยู่หลังจากปิดการเชื่อมต่อฐานข้อมูล

   เพื่อใช้ SQLite ในโหมด in-memory ให้ใช้สตริง `':memory:'` เป็นพาธของไฟล์ฐานข้อมูลเมื่อเชื่อมต่อ ตัวอย่างเช่น

   ```python
   # สร้างฐานข้อมูล in-memory
   conn = sqlite3.connect(':memory:')
   ```

   ด้วยการใช้งานในหน่วยความจำ จะทำให้ SQLite ทำงานได้รวดเร็วยิ่งขึ้นเนื่องจากไม่ต้องเขียนข้อมูลลงดิสก์ ซึ่งเหมาะสำหรับการทดสอบประสิทธิภาพหรือเมื่อต้องการเก็บข้อมูลชั่วคราวระหว่างเซสชันการทำงาน อย่างไรก็ตาม เมื่อปิดการเชื่อมต่อ ข้อมูลทั้งหมดในฐานข้อมูล in-memory จะหายไป

   เรียกได้ว่าสะดวกและง่ายมาก ๆ ในการติดตั้งและตั้งค่า SQLite กับ Python เพียงไม่กี่บรรทัด คุณก็พร้อมที่จะเริ่มพัฒนาแอปพลิเคชันด้วยฐานข้อมูล SQLite ได้ทันที

   การเชื่อมต่อกับฐานข้อมูล SQLite ใน Python

1. ใช้โมดูล `sqlite3`

   เพื่อเชื่อมต่อและทำงานกับฐานข้อมูล SQLite ใน Python คุณจะต้องใช้โมดูล `sqlite3` ซึ่งเป็นส่วนหนึ่งของไลบรารีมาตรฐานของ Python ในการ import โมดูล `sqlite3` ให้ใช้คำสั่งดังนี้

   ```python
   import sqlite3
   ```

   หลังจาก import แล้ว คุณสามารถเรียกใช้ฟังก์ชันและคลาสต่าง ๆ ภายในโมดูล `sqlite3` เพื่อทำงานกับฐานข้อมูล SQLite

2. สร้างออบเจ็กต์การเชื่อมต่อด้วย `sqlite3.connect()`

   เพื่อสร้างการเชื่อมต่อกับฐานข้อมูล SQLite ใช้ฟังก์ชัน `sqlite3.connect()` โดยระบุพาธไปยังไฟล์ฐานข้อมูลหรือใช้ `':memory:'` สำหรับฐานข้อมูล in-memory ตัวอย่างเช่น

   ```python
   conn = sqlite3.connect('mydatabase.db')
   ```

   ฟังก์ชัน `connect()` จะส่งคืนออบเจ็กต์การเชื่อมต่อ (connection object) ที่ใช้ในการโต้ตอบกับฐานข้อมูล เราตั้งชื่อตัวแปรว่า `conn` แต่คุณสามารถใช้ชื่ออื่นที่สื่อความหมายได้

3. การเปิดและปิดการเชื่อมต่อ

   หลังจากสร้างการเชื่อมต่อแล้ว คุณสามารถดำเนินการต่าง ๆ กับฐานข้อมูลได้ เมื่อเสร็จสิ้นการทำงาน ควรปิดการเชื่อมต่อโดยใช้เมธอด `close()` บนออบเจ็กต์การเชื่อมต่อ

   ```python
   conn.close()
   ```

   การปิดการเชื่อมต่อจะช่วยคืนทรัพยากรให้กับระบบปฏิบัติการ เป็นแนวทางปฏิบัติที่ดีในการปิดการเชื่อมต่อเมื่อไม่ได้ใช้งานแล้ว

   นอกจากนี้ คุณยังสามารถใช้คีย์เวิร์ด `with` ในการจัดการการเชื่อมต่อแบบอัตโนมัติ ตัวอย่างเช่น

   ```python
   with sqlite3.connect('mydatabase.db') as conn:
       # ดำเนินการกับฐานข้อมูล
       pass
   ```

   เมื่อออกจากบล็อก `with` Python จะปิดการเชื่อมต่ออัตโนมัติ

4. การกำหนด `row_factory` เพื่อระบุวิธีที่ cursor ส่งคืนแถว

   เมื่อคุณดำเนินการคิวรี (query) กับฐานข้อมูล SQLite ผลลัพธ์จะถูกส่งคืนเป็นออบเจ็กต์ cursor ซึ่งโดยค่าเริ่มต้นจะส่งคืนแถวข้อมูลเป็น tuples อย่างไรก็ตาม คุณสามารถปรับแต่งวิธีที่ cursor ส่งคืนแถวได้โดยกำหนดแอตทริบิวต์ `row_factory` ของออบเจ็กต์การเชื่อมต่อ

   ตัวอย่างทั่วไปคือการใช้คลาส `sqlite3.Row` ซึ่งทำให้สามารถเข้าถึงข้อมูลในแถวได้ทั้งจากดัชนีและชื่อคอลัมน์ เช่น

   ```python
   conn.row_factory = sqlite3.Row
   ```

   หลังจากกำหนด `row_factory` แล้ว คุณสามารถเข้าถึงข้อมูลในแถวได้หลายวิธี เช่น

   ```python
   cursor = conn.execute('SELECT * FROM users')
   row = cursor.fetchone()
   print(row['name'])  # เข้าถึงด้วยชื่อคอลัมน์
   print(row[1])       # เข้าถึงด้วยดัชนี
   ```

   การใช้ `sqlite3.Row` ช่วยให้โค้ดอ่านง่ายและเข้าใจง่ายขึ้น อย่างไรก็ตาม คุณสามารถใช้ `row_factory` อื่น ๆ ได้ เช่น คลาสที่กำหนดเองหรือฟังก์ชันเพื่อแปลงแถวเป็นรูปแบบอื่น
การสร้างและจัดการตาราง

1. ใช้ SQL CREATE TABLE เพื่อสร้างตารางใหม่

   ในการสร้างตารางใหม่ในฐานข้อมูล SQLite ใช้คำสั่ง SQL `CREATE TABLE` ตามด้วยชื่อตารางและรายการคอลัมน์ภายในวงเล็บ ตัวอย่างเช่น

   ```sql
   CREATE TABLE users (
       id INTEGER PRIMARY KEY,
       name TEXT NOT NULL,
       email TEXT UNIQUE
   );
   ```

   ในตัวอย่างนี้ เราสร้างตารางชื่อ `users` ที่มีคอลัมน์ `id`, `name`, และ `email`

2. กำหนดชนิดข้อมูลคอลัมน์ (TEXT, INTEGER, REAL, BLOB)

   เมื่อสร้างตาราง คุณต้องระบุชนิดข้อมูลสำหรับแต่ละคอลัมน์ SQLite รองรับชนิดข้อมูลหลักๆ ดังนี้
   - `TEXT`: สตริงข้อความ เก็บข้อมูลได้สูงสุด 1 พันล้านไบต์
   - `INTEGER`: เลขจำนวนเต็ม (ทั้งบวกและลบ)
   - `REAL`: เลขทศนิยม (จำนวนจริง)
   - `BLOB`: ไบนารีข้อมูล (Binary Large Object) ใช้เก็บข้อมูลไบนารี เช่น รูปภาพหรือไฟล์

   SQLite มีการพิจารณาชนิดข้อมูลแบบไดนามิก แม้ระบุชนิดข้อมูลสำหรับคอลัมน์ แต่ SQLite ก็ยังสามารถเก็บข้อมูลชนิดอื่นในคอลัมน์นั้นได้ อย่างไรก็ตาม แนะนำให้ระบุชนิดข้อมูลที่ถูกต้องเพื่อประสิทธิภาพและความสอดคล้องของข้อมูล

3. การใช้ข้อจำกัด (constraints) เช่น PRIMARY KEY, UNIQUE, NOT NULL, DEFAULT

   ข้อจำกัด (Constraints) ใช้เพื่อกำหนดกฎสำหรับข้อมูลในตาราง SQLite รองรับข้อจำกัดหลายประเภท เช่น
   - `PRIMARY KEY`: ระบุคอลัมน์ที่เป็นคีย์หลัก ซึ่งเป็นตัวระบุเอกลักษณ์ของแถวในตาราง
   - `UNIQUE`: ตรวจสอบว่าค่าในคอลัมน์ไม่ซ้ำกัน
   - `NOT NULL`: กำหนดว่าคอลัมน์ต้องไม่เป็นค่า NULL
   - `DEFAULT`: กำหนดค่าเริ่มต้นสำหรับคอลัมน์เมื่อไม่มีการระบุค่า

   ตัวอย่างการใช้ข้อจำกัด:

   ```sql
   CREATE TABLE products (
       id INTEGER PRIMARY KEY,
       name TEXT NOT NULL,
       price REAL DEFAULT 0.0,
       description TEXT
   );
   ```

   ในตัวอย่างนี้ `id` เป็น PRIMARY KEY, `name` ต้องไม่เป็น NULL, `price` มีค่าเริ่มต้นเป็น 0.0

4. การใช้ AUTOINCREMENT กับคอลัมน์ PRIMARY KEY

   ในการสร้างคีย์หลักที่เพิ่มค่าขึ้นอัตโนมัติเมื่อมีการเพิ่มแถวใหม่ ใช้ `AUTOINCREMENT` กับคอลัมน์ `INTEGER PRIMARY KEY` ตัวอย่างเช่น

   ```sql
   CREATE TABLE orders (
       id INTEGER PRIMARY KEY AUTOINCREMENT,
       customer_id INTEGER,
       total REAL
   );
   ```

   เมื่อคุณเพิ่มแถวใหม่ลงในตาราง `orders` คอลัมน์ `id` จะได้รับการกำหนดค่าโดยอัตโนมัติด้วยจำนวนเต็มที่เพิ่มขึ้น

5. การสร้างความสัมพันธ์ระหว่างตารางด้วย FOREIGN KEY

   Foreign Key ใช้เพื่อสร้างความสัมพันธ์ระหว่างตาราง โดยอ้างอิงไปยังคีย์หลักในตารางอื่น ตัวอย่างเช่น

   ```sql
   CREATE TABLE orders (
       id INTEGER PRIMARY KEY,
       customer_id INTEGER,
       total REAL,
       FOREIGN KEY (customer_id) REFERENCES customers(id)
   );
   ```

   ในตัวอย่างนี้ คอลัมน์ `customer_id` ในตาราง `orders` เป็น Foreign Key ที่อ้างอิงไปยังคอลัมน์ `id` ในตาราง `customers` สิ่งนี้ทำให้มั่นใจได้ว่า `customer_id` ในตาราง `orders` ตรงกับ `id` ที่มีอยู่ในตาราง `customers`
การแทรกข้อมูลลงในตาราง

1. ใช้ SQL INSERT เพื่อแทรกข้อมูลใหม่

   ในการแทรกข้อมูลลงในตาราง ใช้คำสั่ง SQL `INSERT INTO` ตามด้วยชื่อตารางและรายการคอลัมน์ที่ต้องการแทรกข้อมูลภายในวงเล็บ จากนั้นใช้คำสั่ง `VALUES` และระบุค่าสำหรับแต่ละคอลัมน์ ตัวอย่างเช่น

   ```sql
   INSERT INTO users (name, email) VALUES ('John Doe', 'john@example.com');
   ```

   คำสั่งนี้จะแทรกแถวใหม่ลงในตาราง `users` โดยมีค่า `'John Doe'` สำหรับคอลัมน์ `name` และ `'john@example.com'` สำหรับคอลัมน์ `email`

2. การใช้แทรกตัวแปรลงในคำสั่ง SQL อย่างปลอดภัยด้วย placeholders

   เมื่อแทรกข้อมูลที่ได้รับจากผู้ใช้หรือจากซอร์สอื่นๆ ควรใช้ placeholders แทนการใส่ค่าโดยตรงในคำสั่ง SQL เพื่อป้องกันช่องโหว่ SQL Injection ใน Python คุณสามารถใช้เครื่องหมายคำถาม `?` เป็น placeholder และส่งค่าเป็นทูเพิลเป็นอาร์กิวเมนต์ที่สองในเมธอด `execute()` ตัวอย่างเช่น

   ```python
   name = 'Jane Smith'
   email = 'jane@example.com'
   cursor.execute("INSERT INTO users (name, email) VALUES (?, ?)", (name, email))
   ```

   วิธีนี้ SQLite จะจัดการกับการเอสเคปอักขระพิเศษและป้องกันการโจมตีแบบ SQL Injection

3. การแทรกหลายแถวพร้อมกันด้วย `executemany()`

   หากคุณต้องการแทรกหลายแถวพร้อมกัน สามารถใช้เมธอด `executemany()` แทนการเรียก `execute()` หลายครั้ง การใช้ `executemany()` จะมีประสิทธิภาพกว่าเนื่องจากลดจำนวนการโต้ตอบกับฐานข้อมูล

   `executemany()` รับพารามิเตอร์สองตัว: คำสั่ง SQL ที่มี placeholders และลิสต์ของทูเพิลที่มีค่าสำหรับแต่ละชุดข้อมูลที่จะแทรก ตัวอย่างเช่น

   ```python
   data = [
       ('Alice', 'alice@example.com'),
       ('Bob', 'bob@example.com'),
       ('Charlie', 'charlie@example.com')
   ]
   cursor.executemany("INSERT INTO users (name, email) VALUES (?, ?)", data)
   ```

   โค้ดนี้จะแทรกสามแถวลงในตาราง `users` โดยใช้ข้อมูลจากลิสต์ `data`

การแทรกข้อมูลลงในตารางอย่างถูกต้องและปลอดภัยนั้นสำคัญมาก การใช้ placeholders ช่วยป้องกันข้อผิดพลาดและช่องโหว่ด้านความปลอดภัยเมื่อจัดการกับข้อมูลจากภายนอก หากคุณต้องแทรกข้อมูลจำนวนมาก ให้ใช้ `executemany()` เพื่อเพิ่มประสิทธิภาพ


## การค้นข้อมูลจากตาราง
1. ใช้ SQL SELECT เพื่อค้นข้อมูล
   
   ในการค้นข้อมูลจากตาราง ใช้คำสั่ง SQL `SELECT` ตามด้วยรายการคอลัมน์ที่ต้องการ และคำสั่ง `FROM` ตามด้วยชื่อตาราง ตัวอย่างเช่น

   ```sql
   SELECT id, name, email FROM users;
   ```

   คำสั่งนี้จะค้นคอลัมน์ `id`, `name` และ `email` จากตาราง `users`

   หากต้องการค้นทุกคอลัมน์ สามารถใช้เครื่องหมายดอกจัน `*` แทนการระบุชื่อคอลัมน์ทั้งหมด เช่น

   ```sql
   SELECT * FROM users;
   ```

2. การกรองข้อมูลด้วย WHERE clause

   ใช้ `WHERE` clause เพื่อกรองข้อมูลตามเงื่อนไขที่กำหนด โดยระบุเงื่อนไขหลังคำสั่ง `WHERE` ตัวอย่างเช่น

   ```sql
   SELECT * FROM users WHERE email = 'john@example.com';
   ```

   คำสั่งนี้จะค้นเฉพาะแถวที่มีค่า `email` เท่ากับ `'john@example.com'` จากตาราง `users`

   นอกจาก `=` แล้ว คุณยังสามารถใช้ตัวดำเนินการเปรียบเทียบอื่นๆ เช่น `<`, `>`, `<=`, `>=`, `<>` (ไม่เท่ากับ), และตัวดำเนินการตรรกะ `AND`, `OR`, `NOT` เพื่อสร้างเงื่อนไขที่ซับซ้อนขึ้น

3. การเรียงลำดับผลลัพธ์ด้วย ORDER BY

   ใช้ `ORDER BY` clause เพื่อเรียงลำดับผลลัพธ์ตามคอลัมน์ที่ระบุ ตามด้วย `ASC` (เรียงจากน้อยไปมาก) หรือ `DESC` (เรียงจากมากไปน้อย) ตัวอย่างเช่น

   ```sql
   SELECT * FROM users ORDER BY name ASC;
   ```

   คำสั่งนี้จะค้นแถวทั้งหมดจากตาราง `users` โดยเรียงลำดับตามคอลัมน์ `name` จากน้อยไปมาก

4. การจำกัดจำนวนผลลัพธ์ด้วย LIMIT และ OFFSET

   ใช้ `LIMIT` เพื่อจำกัดจำนวนแถวที่ค้น และใช้ `OFFSET` เพื่อข้ามแถวตามจำนวนที่ระบุก่อนเริ่มค้น ตัวอย่างเช่น

   ```sql
   SELECT * FROM users LIMIT 10 OFFSET 20;
   ```

   คำสั่งนี้จะค้นสูงสุด 10 แถวจากตาราง `users` โดยข้าม 20 แถวแรก

   `LIMIT` และ `OFFSET` มักใช้สำหรับการแบ่งหน้าผลลัพธ์ (pagination) เพื่อแสดงข้อมูลทีละส่วนแทนที่จะดึงข้อมูลทั้งหมดมาที่ฝั่งไคลเอ็นต์

5. การใช้ JOIN เพื่อค้นข้อมูลจากหลายตาราง

   ใช้ `JOIN` เพื่อรวมแถวจากตั้งแต่สองตารางขึ้นไปตามความสัมพันธ์ที่กำหนดไว้ ตัวอย่างเช่น

   ```sql
   SELECT orders.id, customers.name, orders.total
   FROM orders
   INNER JOIN customers ON orders.customer_id = customers.id;
   ```

   คำสั่งนี้จะค้นข้อมูลจากตาราง `orders` และ `customers` โดยใช้ `INNER JOIN` เพื่อรวมแถวจากทั้งสองตารางตามความสัมพันธ์ระหว่างคอลัมน์ `customer_id` ในตาราง `orders` และคอลัมน์ `id` ในตาราง `customers`

   มี `JOIN` หลายประเภท เช่น `INNER JOIN`, `LEFT JOIN`, `RIGHT JOIN`, `FULL OUTER JOIN` ซึ่งใช้รวมตารางในลักษณะต่างๆ

การค้นข้อมูลอย่างมีประสิทธิภาพเป็นสิ่งสำคัญในการสร้างแอปพลิเคชันที่ขับเคลื่อนด้วยข้อมูล คุณสามารถใช้เทคนิคต่างๆ เหล่านี้เพื่อดึงข้อมูลที่ต้องการจากฐานข้อมูล SQLite และประมวลผลต่อในแอปพลิเคชันของคุณ


## การอัปเดตและลบข้อมูล

1. ใช้ SQL UPDATE เพื่ออัปเดตข้อมูลที่มีอยู่

   ในการอัปเดตข้อมูลในตาราง ใช้คำสั่ง SQL `UPDATE` ตามด้วยชื่อตาราง, คำสั่ง `SET` และคู่คอลัมน์/ค่าที่ต้องการอัปเดต ใช้คำสั่ง `WHERE` เพื่อระบุแถวที่ต้องการอัปเดต ตัวอย่างเช่น

   ```sql
   UPDATE users SET email = 'johndoe@example.com' WHERE id = 1;
   ```

   คำสั่งนี้จะอัปเดตค่าในคอลัมน์ `email` เป็น `'johndoe@example.com'` สำหรับแถวที่มี `id` เท่ากับ 1 ในตาราง `users`

   เมื่ออัปเดตหลายคอลัมน์ ให้คั่นแต่ละคู่คอลัมน์/ค่าด้วยเครื่องหมายจุลภาค เช่น

   ```sql
   UPDATE users SET name = 'John Doe', email = 'johndoe@example.com' WHERE id = 1;
   ```

2. ใช้ SQL DELETE เพื่อลบข้อมูล

   ในการลบแถวจากตาราง ใช้คำสั่ง SQL `DELETE FROM` ตามด้วยชื่อตาราง และคำสั่ง `WHERE` เพื่อระบุแถวที่ต้องการลบ ตัวอย่างเช่น

   ```sql
   DELETE FROM users WHERE id = 1;
   ```

   คำสั่งนี้จะลบแถวที่มี `id` เท่ากับ 1 จากตาราง `users`

   หากต้องการลบทุกแถวในตาราง ใช้คำสั่ง `DELETE FROM` โดยไม่มี `WHERE` clause เช่น

   ```sql
   DELETE FROM users;
   ```

   โปรดใช้ความระมัดระวังเมื่อใช้คำสั่ง `DELETE` โดยไม่มี `WHERE` เนื่องจากจะเป็นการลบข้อมูลทั้งหมดออกจากตาราง

3. ระวังการใช้ WHERE เพื่อหลีกเลี่ยงการอัปเดตหรือลบข้อมูลทั้งหมดโดยไม่ตั้งใจ

   เมื่ออัปเดตหรือลบข้อมูล ให้ตรวจสอบให้แน่ใจว่าคุณได้ใส่ `WHERE` clause ที่ถูกต้องเพื่อระบุเฉพาะแถวที่คุณต้องการแก้ไข หากลืมใส่ `WHERE` หรือระบุเงื่อนไข `WHERE` ไม่ถูกต้อง อาจเป็นการอัปเดตหรือลบข้อมูลทั้งหมดในตารางโดยไม่ตั้งใจ

   ก่อนรันคำสั่ง `UPDATE` หรือ `DELETE` ให้ทดสอบเงื่อนไข `WHERE` กับคำสั่ง `SELECT` ก่อนเพื่อตรวจสอบว่าคุณได้ระบุแถวที่ถูกต้อง ตัวอย่างเช่น ก่อนรันคำสั่งนี้:

   ```sql
   DELETE FROM users WHERE id = 1;
   ```

   ให้ทดสอบเงื่อนไข `WHERE` กับคำสั่ง `SELECT` ก่อน:

   ```sql
   SELECT * FROM users WHERE id = 1;
   ```

   ตรวจสอบผลลัพธ์เพื่อยืนยันว่าคำสั่ง `SELECT` ค้นคืนเฉพาะแถวที่คุณต้องการลบ หากถูกต้อง จึงดำเนินการรันคำสั่ง `DELETE`

การอัปเดตและลบข้อมูลเป็นการดำเนินการที่สำคัญซึ่งต้องทำด้วยความระมัดระวัง การใช้ `WHERE` clause อย่างถูกต้องจะช่วยให้มั่นใจว่าคุณกำลังแก้ไขเฉพาะข้อมูลที่คุณตั้งใจจะเปลี่ยนแปลง การทดสอบเงื่อนไข `WHERE` ด้วยคำสั่ง `SELECT` ก่อนดำเนินการเปลี่ยนแปลงข้อมูลจริงเป็นแนวทางปฏิบัติที่ดีเพื่อป้องกันการอัปเดตหรือลบข้อมูลโดยไม่ตั้งใจ


## การทำธุรกรรม (Transactions)

1. ความสำคัญของธุรกรรมในการรักษาความสมบูรณ์ของข้อมูล

   ธุรกรรม (Transaction) คือกลุ่มของการดำเนินการในฐานข้อมูลที่ต้องทำงานร่วมกันเป็นหน่วยเดียว ธุรกรรมช่วยให้มั่นใจได้ว่าข้อมูลยังคงความถูกต้องและสอดคล้องกันแม้ในกรณีที่เกิดข้อผิดพลาดหรือการขัดจังหวะ

   ธุรกรรมต้องมีคุณสมบัติ ACID ได้แก่
   - Atomicity (ความเป็นหน่วยเดียว): ธุรกรรมต้องดำเนินการทั้งหมดหรือไม่เลย ไม่มีสถานะกึ่งกลาง
   - Consistency (ความสอดคล้อง): ธุรกรรมต้องนำฐานข้อมูลจากสถานะที่สอดคล้องไปยังสถานะที่สอดคล้องใหม่
   - Isolation (การแยกจากกัน): ธุรกรรมที่ดำเนินการพร้อมกันต้องไม่มีผลกระทบซึ่งกันและกัน
   - Durability (ความคงทน): เมื่อยืนยันธุรกรรมแล้ว การเปลี่ยนแปลงต้องถาวรแม้ในกรณีที่เกิดข้อผิดพลาดหรือระบบล้มเหลว

   ตัวอย่างเช่น สมมติว่าคุณกำลังโอนเงินระหว่างบัญชีธนาคารสองบัญชี ขั้นตอนคือ 1) หักเงินจากบัญชีต้นทาง และ 2) เพิ่มเงินในบัญชีปลายทาง ทั้งสองขั้นตอนต้องดำเนินการสำเร็จหรือไม่สำเร็จพร้อมกัน เพื่อป้องกันไม่ให้เงินหายไปหรือถูกเพิ่มสองครั้ง

2. การเริ่มต้น commit และ rollback ธุรกรรม

   ในการเริ่มต้นธุรกรรมใน SQLite ให้ใช้คำสั่ง `BEGIN TRANSACTION` เช่น

   ```sql
   BEGIN TRANSACTION;
   ```

   จากนั้นดำเนินการเปลี่ยนแปลงข้อมูลตามต้องการ เมื่อพร้อมที่จะบันทึกการเปลี่ยนแปลง ให้ใช้คำสั่ง `COMMIT` เช่น

   ```sql
   COMMIT;
   ```

   หากต้องการยกเลิกการเปลี่ยนแปลงและเปลี่ยนกลับไปใช้สถานะก่อนเริ่มต้นธุรกรรม ให้ใช้คำสั่ง `ROLLBACK` เช่น

   ```sql
   ROLLBACK;
   ```

   ตัวอย่างการใช้ธุรกรรม:

   ```sql
   BEGIN TRANSACTION;
   UPDATE accounts SET balance = balance - 100 WHERE id = 1;
   UPDATE accounts SET balance = balance + 100 WHERE id = 2;
   COMMIT;
   ```

   ในตัวอย่างนี้ เราเริ่มต้นธุรกรรม หักเงิน 100 จากบัญชีที่ 1 เพิ่มเงิน 100 ในบัญชีที่ 2 จากนั้น commit การเปลี่ยนแปลง หากเกิดข้อผิดพลาดระหว่างสองคำสั่ง `UPDATE` เราสามารถใช้ `ROLLBACK` เพื่อเปลี่ยนกลับการเปลี่ยนแปลงทั้งหมดและป้องกันข้อมูลไม่สอดคล้องกัน

3. สร้างธุรกรรมแบบอัตโนมัติด้วย context manager ของ Python

   ใน Python คุณสามารถใช้ context manager เพื่อจัดการธุรกรรมอย่างอัตโนมัติ โดยการใช้ออบเจ็กต์ connection เป็น context manager ตัวอย่างเช่น

   ```python
   with conn:
       conn.execute("UPDATE accounts SET balance = balance - 100 WHERE id = 1")
       conn.execute("UPDATE accounts SET balance = balance + 100 WHERE id = 2")
   ```

   เมื่อใช้ `with` พร้อมกับ connection ของ SQLite ธุรกรรมจะเริ่มต้นโดยอัตโนมัติ หากไม่มีข้อผิดพลาด การเปลี่ยนแปลงจะถูก commit เมื่อออกจากบล็อก `with` แต่หากมีข้อผิดพลาดเกิดขึ้นระหว่างนั้น ธุรกรรมจะถูก rollback โดยอัตโนมัติ

   การใช้ context manager ช่วยให้มั่นใจได้ว่าธุรกรรมถูกจัดการอย่างเหมาะสม แม้ในกรณีที่เกิดข้อผิดพลาดหรือการเปลี่ยนแปลงโฟลว์ของโปรแกรม

ธุรกรรมเป็นกลไกสำคัญที่ช่วยรักษาความถูกต้องและความสอดคล้องของข้อมูลในฐานข้อมูล โดยเฉพาะอย่างยิ่งเมื่อมีหลายการดำเนินการที่เกี่ยวข้องหรือเมื่อมีผู้ใช้หลายคนเข้าถึงฐานข้อมูลพร้อมกัน การใช้ธุรกรรมอย่างถูกต้องจะช่วยป้องกันข้อมูลเสียหายและทำให้มั่นใจได้ว่าฐานข้อมูลของคุณพร้อมใช้งานและเชื่อถือได้

การใช้ SQLite กับ Flask

1. สร้างการเชื่อมต่อฐานข้อมูลใน Flask route หรือ view function

   ในการเชื่อมต่อกับฐานข้อมูล SQLite ใน Flask ให้สร้างออบเจ็กต์การเชื่อมต่อภายใน route หรือ view function ตัวอย่างเช่น

   ```python
   import sqlite3
   from flask import Flask, render_template, request, redirect

   app = Flask(__name__)

   @app.route('/')
   def index():
       conn = sqlite3.connect('mydatabase.db')
       cursor = conn.cursor()
       cursor.execute('SELECT * FROM users')
       users = cursor.fetchall()
       conn.close()
       return render_template('index.html', users=users)
   ```

   ในตัวอย่างนี้ เราสร้าง connection ไปยังฐานข้อมูล `mydatabase.db` ภายใน route `index` จากนั้นใช้ cursor เพื่อดำเนินการคิวรีและดึงข้อมูลผู้ใช้ทั้งหมด เมื่อเสร็จแล้วจึงปิด connection และส่งต่อข้อมูลผู้ใช้ไปยังเทมเพลต `index.html`

2. การส่งผ่านข้อมูลจากฟอร์มไปยังฐานข้อมูล

   เมื่อผู้ใช้ส่งข้อมูลผ่านฟอร์มใน Flask คุณสามารถเข้าถึงข้อมูลนั้นผ่านออบเจ็กต์ `request` เพื่อบันทึกข้อมูลลงในฐานข้อมูล SQLite ตัวอย่างเช่น

   ```python
   @app.route('/add', methods=['POST'])
   def add_user():
       name = request.form['name']
       email = request.form['email']
       conn = sqlite3.connect('mydatabase.db')
       cursor = conn.cursor()
       cursor.execute('INSERT INTO users (name, email) VALUES (?, ?)', (name, email))
       conn.commit()
       conn.close()
       return redirect('/')
   ```

   ในตัวอย่างนี้ เรากำหนด route `/add` ให้รับ HTTP POST request เมื่อผู้ใช้ส่งฟอร์ม เราเข้าถึงข้อมูลชื่อและอีเมลผ่าน `request.form` จากนั้นใช้ cursor เพื่อแทรกข้อมูลใหม่ลงในตาราง `users` ยืนยันการเปลี่ยนแปลง ปิด connection และ redirect กลับไปที่หน้า index

3. การแสดงข้อมูลจากฐานข้อมูลในเทมเพลต

   เพื่อแสดงข้อมูลจากฐานข้อมูล SQLite ในเทมเพลต Flask ให้ดึงข้อมูลที่ต้องการโดยใช้ cursor จากนั้นส่งต่อข้อมูลไปยังเทมเพลตด้วยฟังก์ชัน `render_template()` ตัวอย่างเช่น

   ```python
   @app.route('/')
   def index():
       conn = sqlite3.connect('mydatabase.db')
       cursor = conn.cursor()
       cursor.execute('SELECT * FROM users')
       users = cursor.fetchall()
       conn.close()
       return render_template('index.html', users=users)
   ```

   ในเทมเพลต `index.html` คุณสามารถวนลูปผ่านข้อมูล `users` เพื่อแสดงรายการผู้ใช้ เช่น

   ```html
   <ul>
     {% for user in users %}
       <li>{{ user.name }} - {{ user.email }}</li>
     {% endfor %}
   </ul>
   ```

4. วิธีการรับมือกับข้อผิดพลาดและยกเว้น

   เมื่อทำงานกับฐานข้อมูล SQLite ใน Flask ควรใช้การจัดการข้อผิดพลาดเพื่อรับมือกับปัญหาที่อาจเกิดขึ้น เช่น การเชื่อมต่อฐานข้อมูลล้มเหลว คิวรีที่ไม่ถูกต้อง หรือข้อผิดพลาดอื่น ๆ

   คุณสามารถใช้บล็อก `try/except` เพื่อจับและจัดการข้อผิดพลาด ตัวอย่างเช่น

   ```python
   @app.route('/')
   def index():
       try:
           conn = sqlite3.connect('mydatabase.db')
           cursor = conn.cursor()
           cursor.execute('SELECT * FROM users')
           users = cursor.fetchall()
           conn.close()
           return render_template('index.html', users=users)
       except sqlite3.Error as e:
           return f"Database error: {e}", 500
   ```

   ในตัวอย่างนี้ หากเกิดข้อผิดพลาด SQLite ใด ๆ ระหว่างการเชื่อมต่อหรือคิวรีฐานข้อมูล เราจับข้อผิดพลาดและส่งกลับข้อความข้อผิดพลาดพร้อมรหัสสถานะ HTTP 500 (Internal Server Error)

   นอกจากนี้ Flask ยังมีกลไกการจัดการข้อผิดพลาดในตัว เช่น route `@app.errorhandler(500)` ซึ่งสามารถใช้เพื่อจัดการข้อผิดพลาด HTTP 500 โดยเฉพาะ

ข้อกำหนดและข้อจำกัดของ SQLite

1. ข้อจำกัด เช่น การขาดการสนับสนุนการเขียนแบบ concurrent ข้อจำกัดของขนาดข้อมูล

   แม้ว่า SQLite จะเป็นทางเลือกที่ยอดเยี่ยมสำหรับหลายกรณี แต่ก็มีข้อจำกัดบางประการที่ควรพิจารณา ข้อจำกัดที่สำคัญบางประการ ได้แก่

   - ขาดการสนับสนุนการเขียนแบบ concurrent: SQLite ล็อกทั้งไฟล์ฐานข้อมูลระหว่างการเขียน ซึ่งหมายความว่าสามารถเขียนได้ทีละหนึ่งการทำงานเท่านั้น แม้จะมีหลาย connection พร้อมกัน ถ้าแอปพลิเคชันของคุณต้องการรองรับการเขียนแบบ concurrent SQLite อาจไม่ใช่ตัวเลือกที่ดีที่สุด
   - ข้อจำกัดของขนาดข้อมูล: SQLite สามารถจัดการฐานข้อมูลขนาดใหญ่ได้ (สูงสุด 140 TB) แต่ประสิทธิภาพอาจลดลงสำหรับฐานข้อมูลขนาดใหญ่มาก เนื่องจากการออกแบบที่เน้นความง่ายและพกพาได้ ถ้าคุณวางแผนที่จะจัดเก็บและเรียกใช้ข้อมูลจำนวนมาก ระบบฐานข้อมูลอื่น ๆ อาจเหมาะสมกว่า

2. วิธีจัดการข้อมูลจำนวนมาก

   ถ้าคุณต้องจัดการกับข้อมูลจำนวนมากใน SQLite วิธีต่อไปนี้อาจช่วยปรับปรุงประสิทธิภาพ:

   - ใช้ธุรกรรมเพื่อรวมหลายการดำเนินการเข้าด้วยกัน: แทนที่จะดำเนินการแทรกหรืออัปเดตหลายครั้ง ให้ใช้ธุรกรรมเพื่อรวมการดำเนินการเหล่านั้นเข้าด้วยกัน ซึ่งจะช่วยลดโอเวอร์เฮดและปรับปรุงประสิทธิภาพ
   - สร้างดัชนีในคอลัมน์ที่ใช้บ่อย: ถ้าคุณดำเนินการคิวรีเดียวกันซ้ำๆ ให้พิจารณาสร้างดัชนีในคอลัมน์ที่เกี่ยวข้องเพื่อเพิ่มความเร็วในการค้นหา อย่างไรก็ตาม โปรดทราบว่าดัชนีจะเพิ่มโอเวอร์เฮดในการแทรกและอัปเดต
   - ใช้ VACUUM เพื่อเพิ่มประสิทธิภาพฐานข้อมูล: ในช่วงเวลาหนึ่ง ไฟล์ฐานข้อมูล SQLite อาจมีพื้นที่ว่างที่ไม่ได้ใช้ การรันคำสั่ง VACUUM จะจัดระเบียบไฟล์ฐานข้อมูลใหม่และลบพื้นที่ว่างที่ไม่ได้ใช้ ซึ่งอาจช่วยปรับปรุงประสิทธิภาพได้

3. เมื่อใดควรพิจารณาใช้ระบบฐานข้อมูลอื่น เช่น MySQL หรือ PostgreSQL

   แม้ว่า SQLite จะเหมาะสำหรับหลายกรณี แต่ในบางสถานการณ์ ระบบฐานข้อมูลอื่น ๆ เช่น MySQL หรือ PostgreSQL อาจเหมาะสมกว่า พิจารณาใช้ระบบฐานข้อมูลอื่นเมื่อ:

   - แอปพลิเคชันของคุณต้องการรองรับการเขียนแบบ concurrent จากหลายการทำงานพร้อมกัน
   - คุณต้องจัดเก็บและจัดการชุดข้อมูลขนาดใหญ่มาก (หลายกิกะไบต์หรือเทราไบต์)
   - แอปพลิเคชันของคุณต้องการคุณสมบัติขั้นสูง เช่น การเรียกใช้ระยะไกล (remote access), การทำ replication, หรือการทำ full-text search
   - คุณต้องการความสามารถในการปรับขนาดมากขึ้น เช่น การรันบนเครื่องเซิร์ฟเวอร์จำนวนมากหรืออินสแตนซ์คลาวด์

   ในสถานการณ์เหล่านี้ ระบบฐานข้อมูลที่มีคุณสมบัติครบถ้วนอย่าง MySQL หรือ PostgreSQL อาจใช้งานได้ดีกว่า อย่างไรก็ตาม สำหรับแอปพลิเคชันส่วนใหญ่ที่ไม่มีข้อกำหนดพิเศษเหล่านี้ SQLite จะยังคงเป็นตัวเลือกที่สะดวกและมีประสิทธิภาพ

การเลือกใช้ระบบฐานข้อมูลที่เหมาะสมขึ้นอยู่กับข้อกำหนดเฉพาะของแอปพลิเคชัน ถ้าคุณกำลังสร้างแอปพลิเคชันขนาดเล็กถึงขนาดกลางด้วย Flask และ SQLite เป็นตัวเลือกที่ดี อย่างไรก็ตาม ถ้าแอปพลิเคชันของคุณเติบโตขึ้น สิ่งสำคัญคือต้องเข้าใจข้อจำกัดของ SQLite และพร้อมที่จะย้ายไปใช้ระบบฐานข้อมูลอื่นเมื่อจำเป็น
